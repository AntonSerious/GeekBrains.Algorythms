1. Описать простейшие алгоритмы
1.1. Возведение в степень *используя чётность степени*

Алгоритм позволяет возводить числа в целую степень n за количество операций не более чем 2*log n.
Соответственно сложность алгоритма O(log n)
Пример: 
a^7 = a * a * a * a * a * a * a . Всего семь операций
Заметим, что a^7 = a^6 * a = (a^3)^2 * a . Всего 5 операций. Суть алгоритма: Берем степень n,
если n четная, то делим n/2. Если n нечетная, то вычитаем 1 и делим пополам. 
С получившимся числом проводим те же самые действия, пока не получится 1. Кол-во итераций, которое мы затратим 
будем эквивалентно кол-во операций умножения при вычислении степени числа. 
Кол-во итераций будет <= 2 * log n. 

1.2. Поиск минимального элемента в массиве

Тут все просто. Считаем по-умолчанию первый элемент минимальным, записываем это значение в переменную min.
Далее, идем по массиву и, если a[n] < min, то min = a[n]. Количество итераций n-1
Сложность алгоритма o(n). 

1.3. Нахождение среднего арифметического массива.
Аналогично предыдущему примеру: придется пройтись по всем элементам массива. 
Количество итераций n 
сложность алгоритма о(n)


2. Подсчитать сложность описанных алгоритмов
написал в п.1

3. Какие правила подсчёта применялись, оставьте комментарии в коде
Считаем кол-во  "уникальынх" действий необходимых для выполнения задачи, 
отбрасываем константные действия(не зависящие от n).

Вообще формализовать правило нахождения сложности алгоритма сложно. 
Если на языке математики - мы просто оцениваем с какой скоростью РАСТЕТ функция (кол-ва итераций) при увеличении аргумента ( кол-ва элементов в массиве, степень возведения, итд).
Сложность алгоритма o( log n) - значит кол-во итераций в алгоритме с ростом n будет расти как log n. 
